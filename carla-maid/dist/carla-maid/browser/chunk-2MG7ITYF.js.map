{
  "version": 3,
  "sources": ["src/app/shared/services/shared.service.ts"],
  "sourcesContent": ["import { HttpParams } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { DomSanitizer, SafeHtml } from '@angular/platform-browser';\nimport { BehaviorSubject } from 'rxjs';\n\ninterface Params {\n  [key: string]: string | number | boolean | (string | number | boolean)[];\n}\n\ninterface Options {\n  allowNull?: boolean;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class SharedService {\n  private selectedPostSubject = new BehaviorSubject<any>(null);\n  selectedPost$ = this.selectedPostSubject.asObservable();\n\n  constructor(\n    private _sanitizer: DomSanitizer,\n  ) { }\n\n  /**\n   * Prepares the query parameters for HTTP requests.\n   * @param {Object} params - The parameters to be processed.\n   * @param {Options} [options] - Optional settings for null values.\n   * @returns {HttpParams} The processed HTTP parameters.\n   */\n  prepareParams({ params, options }: { params: Params; options?: Options }): HttpParams {\n    let httpParams = new HttpParams();\n\n    if (params) {\n      if (!options?.allowNull) {\n        params = Object.fromEntries(\n          Object.entries(params).filter(([_, value]) => value !== null && value !== undefined && value !== '')\n        );\n      }\n\n      for (const [key, value] of Object.entries(params)) {\n        if (Array.isArray(value)) {\n          value.forEach((val, index) => {\n            httpParams = httpParams.append(`${key}[${index}]`, String(val));\n          });\n        } else {\n          httpParams = httpParams.set(key, String(value));\n        }\n      }\n    }\n\n    return httpParams;\n  }\n\n  /**\n   * Sanitizes HTML content for safe usage in the application.\n   * @param {string} content - The HTML content to sanitize.\n   * @returns {SafeHtml} The sanitized HTML content.\n   */\n  sanitizeHtml(content: string): SafeHtml {\n    return this._sanitizer.bypassSecurityTrustHtml(content);\n  }\n\n  /**\n   * Removes all HTML tags and decodes HTML entities from a given string.\n   *\n   * @param {string} html - The input HTML string containing HTML content.\n   * @returns {string} The plain text content without HTML tags and with decoded entities.\n   */\n  stripHtml(html: string): string {\n    if (!html || typeof html !== 'string') {\n      return '';\n    }\n    try {\n      const text = html.replace(/<[^>]*>/g, '');\n\n      const textarea = document.createElement(\"textarea\");\n      textarea.innerHTML = text;\n      return textarea.value;\n    } catch (error) {\n      console.error('Error stripping HTML:', error);\n      return '';\n    }\n  }\n  selectPost(post: any) {\n    this.selectedPostSubject.next(post);\n  }\n\n}"],
  "mappings": ";;;;;;;;;;;AAgBM,IAAO,gBAAP,MAAO,eAAa;EAKd;EAJF,sBAAsB,IAAI,gBAAqB,IAAI;EAC3D,gBAAgB,KAAK,oBAAoB,aAAY;EAErD,YACU,YAAwB;AAAxB,SAAA,aAAA;EACN;;;;;;;EAQJ,cAAc,EAAE,QAAQ,QAAO,GAAyC;AACtE,QAAI,aAAa,IAAI,WAAU;AAE/B,QAAI,QAAQ;AACV,UAAI,CAAC,SAAS,WAAW;AACvB,iBAAS,OAAO,YACd,OAAO,QAAQ,MAAM,EAAE,OAAO,CAAC,CAAC,GAAG,KAAK,MAAM,UAAU,QAAQ,UAAU,UAAa,UAAU,EAAE,CAAC;MAExG;AAEA,iBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AACjD,YAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,gBAAM,QAAQ,CAAC,KAAK,UAAS;AAC3B,yBAAa,WAAW,OAAO,GAAG,GAAG,IAAI,KAAK,KAAK,OAAO,GAAG,CAAC;UAChE,CAAC;QACH,OAAO;AACL,uBAAa,WAAW,IAAI,KAAK,OAAO,KAAK,CAAC;QAChD;MACF;IACF;AAEA,WAAO;EACT;;;;;;EAOA,aAAa,SAAe;AAC1B,WAAO,KAAK,WAAW,wBAAwB,OAAO;EACxD;;;;;;;EAQA,UAAU,MAAY;AACpB,QAAI,CAAC,QAAQ,OAAO,SAAS,UAAU;AACrC,aAAO;IACT;AACA,QAAI;AACF,YAAM,OAAO,KAAK,QAAQ,YAAY,EAAE;AAExC,YAAM,WAAW,SAAS,cAAc,UAAU;AAClD,eAAS,YAAY;AACrB,aAAO,SAAS;IAClB,SAAS,OAAO;AACd,cAAQ,MAAM,yBAAyB,KAAK;AAC5C,aAAO;IACT;EACF;EACA,WAAW,MAAS;AAClB,SAAK,oBAAoB,KAAK,IAAI;EACpC;;qCAtEW,gBAAa,mBAAA,YAAA,CAAA;EAAA;4EAAb,gBAAa,SAAb,eAAa,WAAA,YAFZ,OAAM,CAAA;;",
  "names": []
}
