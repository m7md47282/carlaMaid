{
  "version": 3,
  "sources": ["src/app/shared/services/google-form.service.ts", "src/app/shared/services/booking.service.ts", "src/app/shared/services/payment-data.service.ts"],
  "sourcesContent": ["import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable, throwError } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\nimport { environment } from '../../../environments/environment';\n\n// Google Form interfaces\nexport interface GoogleFormSubmission {\n  orderId: string;\n  paymentId?: string;\n  isPaid: boolean;\n  address: string;\n  customerName: string;\n  customerEmail: string;\n  customerPhone: string;\n  scheduledDate: string;\n  scheduledTime: string;\n  hours: number;\n  materials: boolean;\n  cleaners: number;\n  submissionDate: string;\n}\n\nexport interface GoogleFormResponse {\n  success: boolean;\n  message?: string;\n  error?: string;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class GoogleFormService {\n  private readonly backendApiUrl = environment.backendApiUrl;\n\n  constructor(private http: HttpClient) { }\n\n  /**\n   * Submit booking data to Google Form\n   * @param bookingData - The booking data to submit\n   * @returns Observable with submission response\n   */\n  submitBookingToGoogleForm(bookingData: GoogleFormSubmission): Observable<GoogleFormResponse> {\n    const apiUrl = `${this.backendApiUrl}/google-form/submit-booking`;\n\n    return this.http.post<GoogleFormResponse>(apiUrl, bookingData)\n      .pipe(\n        map(response => {\n          if (response.success) {\n            return {\n              success: true,\n              message: response.message || 'Booking data submitted to Google Form successfully'\n            };\n          } else {\n            return {\n              success: false,\n              error: response.error || 'Failed to submit booking data to Google Form'\n            };\n          }\n        }),\n        catchError(error => {\n          console.error('Google Form submission error:', error);\n          return throwError(() => new Error('Failed to submit booking data to Google Form'));\n        })\n      );\n  }\n\n  /**\n   * Format booking data for Google Form submission\n   * @param bookingData - Raw booking data\n   * @returns Formatted data for Google Form\n   */\n  formatBookingForGoogleForm(bookingData: any): GoogleFormSubmission {\n    return {\n      orderId: bookingData.bookingId || bookingData.id || '',\n      paymentId: bookingData.paymentOrderId || bookingData.payment_order_id || '',\n      isPaid: Boolean(bookingData.isPaid || bookingData.is_paid || false),\n      address: bookingData.address || '',\n      customerName: bookingData.customerName || bookingData.customer_name || '',\n      customerEmail: bookingData.customerEmail || bookingData.customer_email || '',\n      customerPhone: bookingData.customerPhone || bookingData.customer_phone || '',\n      scheduledDate: bookingData.scheduledDate || bookingData.scheduled_date || '',\n      scheduledTime: bookingData.scheduledTime || bookingData.scheduled_time || '',\n      hours: parseInt(bookingData.hours) || 1,\n      materials: Boolean(bookingData.materials),\n      cleaners: parseInt(bookingData.cleaners) || 1,\n      submissionDate: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Validate Google Form submission data\n   * @param submissionData - The data to validate\n   * @returns True if valid, false otherwise\n   */\n  validateSubmissionData(submissionData: GoogleFormSubmission): boolean {\n    return !!(\n      submissionData.customerName?.trim() &&\n      submissionData.customerEmail?.trim() &&\n      submissionData.customerPhone?.trim() &&\n      submissionData.address?.trim() &&\n      submissionData.orderId?.trim()\n    );\n  }\n} ", "import { Injectable } from '@angular/core';\nimport { HttpClient, HttpErrorResponse } from '@angular/common/http';\nimport { Observable, throwError } from 'rxjs';\nimport { catchError, map, switchMap } from 'rxjs/operators';\nimport { environment } from '../../../environments/environment';\nimport { GoogleFormService, GoogleFormSubmission } from './google-form.service';\n\n// ============================================================================\n// INTERFACES\n// ============================================================================\n\nexport interface BookingOrder {\n  id: string;\n  customerName: string;\n  customerEmail: string;\n  customerPhone: string;\n  address: string;\n  serviceType: string;\n  cleaners: number;\n  hours: number;\n  materials: boolean;\n  total: number;\n  paymentMethod: string;\n  status: BookingStatus;\n  createdAt: string;\n  scheduledDate: string;\n  scheduledTime: string;\n}\n\nexport interface BookingRequest {\n  customerName: string;\n  customerEmail: string;\n  customerPhone: string;\n  address: string;\n  serviceType: string;\n  cleaners: number;\n  hours: number;\n  materials: boolean;\n  total: number;\n  paymentMethod: string;\n  scheduledDate: string;\n  scheduledTime: string;\n}\n\nexport interface BookingResponse {\n  success: boolean;\n  orderId?: string;\n  order?: BookingOrder;\n  error?: string;\n}\n\nexport interface PaymentBookingData {\n  customerName: string;\n  customerEmail: string;\n  customerPhone: string;\n  address: string;\n  cleaners: number;\n  hours: number;\n  materials: boolean;\n  scheduledDate: string;\n  scheduledTime: string;\n}\n\nexport type BookingStatus = 'pending' | 'confirmed' | 'completed' | 'cancelled';\n\n// ============================================================================\n// API RESPONSE INTERFACES\n// ============================================================================\n\ninterface ApiResponse<T> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n\ninterface BookingApiResponse extends ApiResponse<BookingOrder> {\n  orderId?: string;\n  order?: BookingOrder;\n}\n\ninterface BookingsListResponse extends ApiResponse<BookingOrder[]> {\n  bookings?: BookingOrder[];\n}\n\n// ============================================================================\n// BOOKING SERVICE\n// ============================================================================\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class BookingService {\n  private readonly backendApiUrl = environment.backendApiUrl;\n\n  constructor(\n    private http: HttpClient,\n    private googleFormService: GoogleFormService\n  ) { }\n\n  // ============================================================================\n  // PUBLIC METHODS\n  // ============================================================================\n\n  /**\n   * Creates a new booking order\n   * @param bookingRequest - The booking request data\n   * @returns Observable with booking response\n   */\n  createBooking(bookingRequest: BookingRequest): Observable<BookingResponse> {\n    const orderData = this.transformBookingRequestToApiFormat(bookingRequest);\n\n    return this.http.post<BookingApiResponse>(`${this.backendApiUrl}/bookings/create`, orderData)\n      .pipe(\n        map(this.handleBookingApiResponse),\n        catchError(this.handleHttpError.bind(this))\n      );\n  }\n\n  /**\n   * Creates a booking with payment information after successful payment\n   * @param bookingData - The booking data\n   * @param paymentOrderId - The payment order ID\n   * @param paymentStatus - The payment status\n   * @returns Observable with booking response\n   */\n  createBookingWithPayment(\n    bookingData: PaymentBookingData, \n    paymentOrderId: string, \n    paymentStatus: string\n  ): Observable<BookingResponse> {\n    const orderData = this.transformPaymentBookingToApiFormat(bookingData, paymentOrderId, paymentStatus);\n\n    return this.http.post<BookingApiResponse>(`${this.backendApiUrl}/bookings/create-with-payment`, orderData)\n      .pipe(\n        map(this.handleBookingApiResponse),\n        switchMap(bookingResponse => {\n          if (bookingResponse.success && bookingResponse.order) {\n            // Submit to Google Form after successful booking creation\n            const googleFormData = this.googleFormService.formatBookingForGoogleForm(bookingResponse.order);\n            return this.googleFormService.submitBookingToGoogleForm(googleFormData).pipe(\n              map(() => bookingResponse) // Return the original booking response\n            );\n          }\n          return [bookingResponse];\n        }),\n        catchError(this.handleHttpError.bind(this))\n      );\n  }\n\n  /**\n   * Retrieves a booking by its ID\n   * @param orderId - The booking order ID\n   * @returns Observable with booking order\n   */\n  getBooking(orderId: string): Observable<BookingOrder> {\n    return this.http.get<BookingApiResponse>(`${this.backendApiUrl}/bookings/${orderId}`)\n      .pipe(\n        map(response => {\n          if (response.success && response.order) {\n            return response.order;\n          }\n          throw new Error(response.error || 'Failed to get booking');\n        }),\n        catchError(this.handleHttpError.bind(this))\n      );\n  }\n\n  /**\n   * Updates the status of a booking\n   * @param orderId - The booking order ID\n   * @param status - The new status\n   * @returns Observable with booking response\n   */\n  updateBookingStatus(orderId: string, status: BookingStatus): Observable<BookingResponse> {\n    return this.http.put<BookingApiResponse>(`${this.backendApiUrl}/bookings/${orderId}/status`, { status })\n      .pipe(\n        map(this.handleBookingApiResponse),\n        catchError(this.handleHttpError.bind(this))\n      );\n  }\n\n  /**\n   * Retrieves all bookings for a customer\n   * @param customerEmail - The customer's email\n   * @returns Observable with array of booking orders\n   */\n  getCustomerBookings(customerEmail: string): Observable<BookingOrder[]> {\n    return this.http.get<BookingsListResponse>(`${this.backendApiUrl}/bookings/customer/${customerEmail}`)\n      .pipe(\n        map(response => {\n          if (response.success && response.bookings) {\n            return response.bookings;\n          }\n          throw new Error(response.error || 'Failed to get customer bookings');\n        }),\n        catchError(this.handleHttpError.bind(this))\n      );\n  }\n\n  /**\n   * Cancels a booking\n   * @param orderId - The booking order ID\n   * @returns Observable with booking response\n   */\n  cancelBooking(orderId: string): Observable<BookingResponse> {\n    return this.http.put<BookingApiResponse>(`${this.backendApiUrl}/bookings/${orderId}/cancel`, {})\n      .pipe(\n        map(this.handleBookingApiResponse),\n        catchError(this.handleHttpError.bind(this))\n      );\n  }\n\n  // ============================================================================\n  // UTILITY METHODS\n  // ============================================================================\n\n  /**\n   * Generates a unique order ID\n   * @returns Generated order ID\n   */\n  generateOrderId(): string {\n    const timestamp = Date.now();\n    const random = Math.random().toString(36).substring(2, 15);\n    return `CARLA_BOOKING_${timestamp}_${random}`.toUpperCase();\n  }\n\n  /**\n   * Validates booking request data\n   * @param bookingRequest - The booking request to validate\n   * @returns True if valid, false otherwise\n   */\n  validateBooking(bookingRequest: BookingRequest): boolean {\n    return !!(\n      bookingRequest.customerName?.trim() &&\n      bookingRequest.customerEmail?.trim() &&\n      bookingRequest.customerPhone?.trim() &&\n      bookingRequest.address?.trim() &&\n      bookingRequest.cleaners > 0 &&\n      bookingRequest.hours > 0 &&\n      bookingRequest.total > 0\n    );\n  }\n\n  /**\n   * Formats booking data for display\n   * @param booking - The booking order to format\n   * @returns Formatted booking data\n   */\n  formatBooking(booking: BookingOrder): BookingOrder & {\n    formattedDate: string;\n    formattedTime: string;\n    formattedTotal: string;\n  } {\n    return {\n      ...booking,\n      formattedDate: new Date(booking.scheduledDate).toLocaleDateString(),\n      formattedTime: booking.scheduledTime,\n      formattedTotal: new Intl.NumberFormat('en-US', {\n        style: 'currency',\n        currency: 'QAR'\n      }).format(booking.total)\n    };\n  }\n\n  // ============================================================================\n  // PRIVATE HELPER METHODS\n  // ============================================================================\n\n  /**\n   * Transforms booking request to API format\n   */\n  private transformBookingRequestToApiFormat(bookingRequest: BookingRequest): Record<string, any> {\n    return {\n      customer_name: bookingRequest.customerName,\n      customer_email: bookingRequest.customerEmail,\n      customer_phone: bookingRequest.customerPhone,\n      address: bookingRequest.address,\n      service_type: bookingRequest.serviceType,\n      cleaners: bookingRequest.cleaners,\n      hours: bookingRequest.hours,\n      materials: bookingRequest.materials,\n      total: bookingRequest.total,\n      payment_method: bookingRequest.paymentMethod,\n      scheduled_date: bookingRequest.scheduledDate,\n      scheduled_time: bookingRequest.scheduledTime\n    };\n  }\n\n  /**\n   * Transforms payment booking data to API format\n   */\n  private transformPaymentBookingToApiFormat(\n    bookingData: PaymentBookingData, \n    paymentOrderId: string, \n    paymentStatus: string\n  ): Record<string, any> {\n    return {\n      customer_name: bookingData.customerName,\n      customer_email: bookingData.customerEmail,\n      customer_phone: bookingData.customerPhone,\n      address: bookingData.address,\n      service_type: 'cleaning',\n      cleaners: bookingData.cleaners,\n      hours: bookingData.hours,\n      materials: bookingData.materials,\n      total: parseFloat(sessionStorage.getItem('paymentAmount') || '0'),\n      payment_method: 'skipcash',\n      payment_order_id: paymentOrderId,\n      payment_status: paymentStatus,\n      is_paid: paymentStatus === 'completed',\n      scheduled_date: bookingData.scheduledDate,\n      scheduled_time: bookingData.scheduledTime\n    };\n  }\n\n  /**\n   * Handles booking API response\n   */\n  private handleBookingApiResponse(response: BookingApiResponse): BookingResponse {\n    if (response.success) {\n      return {\n        success: true,\n        orderId: response.orderId,\n        order: response.order\n      };\n    }\n    \n    return {\n      success: false,\n      error: response.error || 'Operation failed'\n    };\n  }\n\n  /**\n   * Handles HTTP errors\n   */\n  private handleHttpError(error: HttpErrorResponse): Observable<never> {\n    console.error('Booking service error:', error);\n    \n    let errorMessage = 'An unexpected error occurred';\n    \n    if (error.error?.message) {\n      errorMessage = error.error.message;\n    } else if (error.message) {\n      errorMessage = error.message;\n    }\n    \n    return throwError(() => new Error(errorMessage));\n  }\n} ", "import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable, throwError } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\nimport { environment } from '../../../environments/environment';\n\n// Payment data interfaces\nexport interface PaymentDataRequest {\n  paymentOrderId: string;\n  bookingData: any;\n  paymentAmount: number;\n}\n\nexport interface PaymentDataResponse {\n  success: boolean;\n  message?: string;\n  error?: string;\n}\n\nexport interface PaymentDataRetrieval {\n  success: boolean;\n  data?: {\n    bookingData: any;\n    paymentAmount: number;\n    createdAt: string;\n    expiresAt: string;\n  };\n  error?: string;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class PaymentDataService {\n  private readonly backendApiUrl = environment.backendApiUrl;\n\n  constructor(private http: HttpClient) { }\n\n  /**\n   * Store booking data for payment processing\n   * @param paymentOrderId - The payment order ID\n   * @param bookingData - The booking data to store\n   * @param paymentAmount - The payment amount\n   * @returns Observable with storage response\n   */\n  storePaymentData(\n    paymentOrderId: string, \n    bookingData: any, \n    paymentAmount: number\n  ): Observable<PaymentDataResponse> {\n    const apiUrl = `${this.backendApiUrl}/bookings/store-payment-data`;\n\n    const payload: PaymentDataRequest = {\n      paymentOrderId,\n      bookingData,\n      paymentAmount\n    };\n\n    return this.http.post<PaymentDataResponse>(apiUrl, payload)\n      .pipe(\n        map(response => {\n          if (response.success) {\n            return {\n              success: true,\n              message: response.message || 'Payment data stored successfully'\n            };\n          } else {\n            return {\n              success: false,\n              error: response.error || 'Failed to store payment data'\n            };\n          }\n        }),\n        catchError(error => {\n          console.error('Store payment data error:', error);\n          return throwError(() => new Error('Failed to store payment data'));\n        })\n      );\n  }\n\n  /**\n   * Retrieve booking data for payment processing\n   * @param paymentOrderId - The payment order ID\n   * @returns Observable with payment data\n   */\n  retrievePaymentData(paymentOrderId: string): Observable<PaymentDataRetrieval> {\n    const apiUrl = `${this.backendApiUrl}/bookings/payment-data/${paymentOrderId}`;\n\n    return this.http.get<PaymentDataRetrieval>(apiUrl)\n      .pipe(\n        map(response => {\n          if (response.success && response.data) {\n            return {\n              success: true,\n              data: response.data\n            };\n          } else {\n            return {\n              success: false,\n              error: response.error || 'Failed to retrieve payment data'\n            };\n          }\n        }),\n        catchError(error => {\n          console.error('Retrieve payment data error:', error);\n          return throwError(() => new Error('Failed to retrieve payment data'));\n        })\n      );\n  }\n\n  /**\n   * Clean up payment data after successful booking creation\n   * @param paymentOrderId - The payment order ID\n   * @returns Observable with cleanup response\n   */\n  cleanupPaymentData(paymentOrderId: string): Observable<PaymentDataResponse> {\n    const apiUrl = `${this.backendApiUrl}/bookings/payment-data/${paymentOrderId}`;\n\n    return this.http.delete<PaymentDataResponse>(apiUrl)\n      .pipe(\n        map(response => {\n          if (response.success) {\n            return {\n              success: true,\n              message: response.message || 'Payment data cleaned up successfully'\n            };\n          } else {\n            return {\n              success: false,\n              error: response.error || 'Failed to clean up payment data'\n            };\n          }\n        }),\n        catchError(error => {\n          console.error('Cleanup payment data error:', error);\n          return throwError(() => new Error('Failed to clean up payment data'));\n        })\n      );\n  }\n\n  /**\n   * Get payment data from multiple sources (backend, sessionStorage, URL params)\n   * @param paymentOrderId - The payment order ID\n   * @returns Observable with payment data\n   */\n  getPaymentDataFromMultipleSources(paymentOrderId: string): Observable<PaymentDataRetrieval> {\n    return new Observable(observer => {\n      // First try to get from backend\n      this.retrievePaymentData(paymentOrderId).subscribe({\n        next: (backendResponse) => {\n          if (backendResponse.success && backendResponse.data) {\n            observer.next(backendResponse);\n            observer.complete();\n          } else {\n            // Fallback to sessionStorage\n            this.getPaymentDataFromSessionStorage(paymentOrderId).subscribe({\n              next: (sessionResponse) => {\n                if (sessionResponse.success && sessionResponse.data) {\n                  observer.next(sessionResponse);\n                  observer.complete();\n                } else {\n                  observer.next({\n                    success: false,\n                    error: 'Payment data not found in backend or session storage'\n                  });\n                  observer.complete();\n                }\n              },\n              error: (error) => {\n                observer.next({\n                  success: false,\n                  error: 'Failed to retrieve payment data from session storage'\n                });\n                observer.complete();\n              }\n            });\n          }\n        },\n        error: (error) => {\n          // Fallback to sessionStorage\n          this.getPaymentDataFromSessionStorage(paymentOrderId).subscribe({\n            next: (sessionResponse) => {\n              if (sessionResponse.success && sessionResponse.data) {\n                observer.next(sessionResponse);\n                observer.complete();\n              } else {\n                observer.next({\n                  success: false,\n                  error: 'Payment data not found in backend or session storage'\n                });\n                observer.complete();\n              }\n            },\n            error: (sessionError) => {\n              observer.next({\n                success: false,\n                error: 'Failed to retrieve payment data from any source'\n              });\n              observer.complete();\n            }\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * Get payment data from sessionStorage (fallback method)\n   * @param paymentOrderId - The payment order ID\n   * @returns Observable with payment data\n   */\n  private getPaymentDataFromSessionStorage(paymentOrderId: string): Observable<PaymentDataRetrieval> {\n    return new Observable(observer => {\n      try {\n        const storedPaymentOrderId = sessionStorage.getItem('paymentOrderId');\n        const bookingData = sessionStorage.getItem('bookingData');\n        const paymentAmount = sessionStorage.getItem('paymentAmount');\n\n        if (storedPaymentOrderId === paymentOrderId && bookingData && paymentAmount) {\n          const parsedBookingData = JSON.parse(bookingData);\n          const parsedPaymentAmount = parseFloat(paymentAmount);\n\n          observer.next({\n            success: true,\n            data: {\n              bookingData: parsedBookingData,\n              paymentAmount: parsedPaymentAmount,\n              createdAt: new Date().toISOString(),\n              expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()\n            }\n          });\n        } else {\n          observer.next({\n            success: false,\n            error: 'Payment data not found in session storage'\n          });\n        }\n        observer.complete();\n      } catch (error) {\n        observer.next({\n          success: false,\n          error: 'Failed to parse payment data from session storage'\n        });\n        observer.complete();\n      }\n    });\n  }\n\n  /**\n   * Store payment data in sessionStorage (backup method)\n   * @param paymentOrderId - The payment order ID\n   * @param bookingData - The booking data\n   * @param paymentAmount - The payment amount\n   */\n  storePaymentDataInSessionStorage(\n    paymentOrderId: string, \n    bookingData: any, \n    paymentAmount: number\n  ): void {\n    try {\n      sessionStorage.setItem('paymentOrderId', paymentOrderId);\n      sessionStorage.setItem('bookingData', JSON.stringify(bookingData));\n      sessionStorage.setItem('paymentAmount', paymentAmount.toString());\n    } catch (error) {\n      console.error('Failed to store payment data in session storage:', error);\n    }\n  }\n\n  /**\n   * Clear payment data from sessionStorage\n   */\n  clearPaymentDataFromSessionStorage(): void {\n    try {\n      sessionStorage.removeItem('paymentOrderId');\n      sessionStorage.removeItem('bookingData');\n      sessionStorage.removeItem('paymentAmount');\n    } catch (error) {\n      console.error('Failed to clear payment data from session storage:', error);\n    }\n  }\n} "],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAgCM,IAAO,oBAAP,MAAO,mBAAiB;EAGR;EAFH,gBAAgB,YAAY;EAE7C,YAAoB,MAAgB;AAAhB,SAAA,OAAA;EAAoB;;;;;;EAOxC,0BAA0B,aAAiC;AACzD,UAAM,SAAS,GAAG,KAAK,aAAa;AAEpC,WAAO,KAAK,KAAK,KAAyB,QAAQ,WAAW,EAC1D,KACC,IAAI,cAAW;AACb,UAAI,SAAS,SAAS;AACpB,eAAO;UACL,SAAS;UACT,SAAS,SAAS,WAAW;;MAEjC,OAAO;AACL,eAAO;UACL,SAAS;UACT,OAAO,SAAS,SAAS;;MAE7B;IACF,CAAC,GACD,WAAW,WAAQ;AACjB,cAAQ,MAAM,iCAAiC,KAAK;AACpD,aAAO,WAAW,MAAM,IAAI,MAAM,8CAA8C,CAAC;IACnF,CAAC,CAAC;EAER;;;;;;EAOA,2BAA2B,aAAgB;AACzC,WAAO;MACL,SAAS,YAAY,aAAa,YAAY,MAAM;MACpD,WAAW,YAAY,kBAAkB,YAAY,oBAAoB;MACzE,QAAQ,QAAQ,YAAY,UAAU,YAAY,WAAW,KAAK;MAClE,SAAS,YAAY,WAAW;MAChC,cAAc,YAAY,gBAAgB,YAAY,iBAAiB;MACvE,eAAe,YAAY,iBAAiB,YAAY,kBAAkB;MAC1E,eAAe,YAAY,iBAAiB,YAAY,kBAAkB;MAC1E,eAAe,YAAY,iBAAiB,YAAY,kBAAkB;MAC1E,eAAe,YAAY,iBAAiB,YAAY,kBAAkB;MAC1E,OAAO,SAAS,YAAY,KAAK,KAAK;MACtC,WAAW,QAAQ,YAAY,SAAS;MACxC,UAAU,SAAS,YAAY,QAAQ,KAAK;MAC5C,iBAAgB,oBAAI,KAAI,GAAG,YAAW;;EAE1C;;;;;;EAOA,uBAAuB,gBAAoC;AACzD,WAAO,CAAC,EACN,eAAe,cAAc,KAAI,KACjC,eAAe,eAAe,KAAI,KAClC,eAAe,eAAe,KAAI,KAClC,eAAe,SAAS,KAAI,KAC5B,eAAe,SAAS,KAAI;EAEhC;;qCAvEW,oBAAiB,mBAAA,UAAA,CAAA;EAAA;4EAAjB,oBAAiB,SAAjB,mBAAiB,WAAA,YAFhB,OAAM,CAAA;;;;AC6Dd,IAAO,iBAAP,MAAO,gBAAc;EAIf;EACA;EAJO,gBAAgB,YAAY;EAE7C,YACU,MACA,mBAAoC;AADpC,SAAA,OAAA;AACA,SAAA,oBAAA;EACN;;;;;;;;;EAWJ,cAAc,gBAA8B;AAC1C,UAAM,YAAY,KAAK,mCAAmC,cAAc;AAExE,WAAO,KAAK,KAAK,KAAyB,GAAG,KAAK,aAAa,oBAAoB,SAAS,EACzF,KACC,IAAI,KAAK,wBAAwB,GACjC,WAAW,KAAK,gBAAgB,KAAK,IAAI,CAAC,CAAC;EAEjD;;;;;;;;EASA,yBACE,aACA,gBACA,eAAqB;AAErB,UAAM,YAAY,KAAK,mCAAmC,aAAa,gBAAgB,aAAa;AAEpG,WAAO,KAAK,KAAK,KAAyB,GAAG,KAAK,aAAa,iCAAiC,SAAS,EACtG,KACC,IAAI,KAAK,wBAAwB,GACjC,UAAU,qBAAkB;AAC1B,UAAI,gBAAgB,WAAW,gBAAgB,OAAO;AAEpD,cAAM,iBAAiB,KAAK,kBAAkB,2BAA2B,gBAAgB,KAAK;AAC9F,eAAO,KAAK,kBAAkB,0BAA0B,cAAc,EAAE;UACtE,IAAI,MAAM,eAAe;;;MAE7B;AACA,aAAO,CAAC,eAAe;IACzB,CAAC,GACD,WAAW,KAAK,gBAAgB,KAAK,IAAI,CAAC,CAAC;EAEjD;;;;;;EAOA,WAAW,SAAe;AACxB,WAAO,KAAK,KAAK,IAAwB,GAAG,KAAK,aAAa,aAAa,OAAO,EAAE,EACjF,KACC,IAAI,cAAW;AACb,UAAI,SAAS,WAAW,SAAS,OAAO;AACtC,eAAO,SAAS;MAClB;AACA,YAAM,IAAI,MAAM,SAAS,SAAS,uBAAuB;IAC3D,CAAC,GACD,WAAW,KAAK,gBAAgB,KAAK,IAAI,CAAC,CAAC;EAEjD;;;;;;;EAQA,oBAAoB,SAAiB,QAAqB;AACxD,WAAO,KAAK,KAAK,IAAwB,GAAG,KAAK,aAAa,aAAa,OAAO,WAAW,EAAE,OAAM,CAAE,EACpG,KACC,IAAI,KAAK,wBAAwB,GACjC,WAAW,KAAK,gBAAgB,KAAK,IAAI,CAAC,CAAC;EAEjD;;;;;;EAOA,oBAAoB,eAAqB;AACvC,WAAO,KAAK,KAAK,IAA0B,GAAG,KAAK,aAAa,sBAAsB,aAAa,EAAE,EAClG,KACC,IAAI,cAAW;AACb,UAAI,SAAS,WAAW,SAAS,UAAU;AACzC,eAAO,SAAS;MAClB;AACA,YAAM,IAAI,MAAM,SAAS,SAAS,iCAAiC;IACrE,CAAC,GACD,WAAW,KAAK,gBAAgB,KAAK,IAAI,CAAC,CAAC;EAEjD;;;;;;EAOA,cAAc,SAAe;AAC3B,WAAO,KAAK,KAAK,IAAwB,GAAG,KAAK,aAAa,aAAa,OAAO,WAAW,CAAA,CAAE,EAC5F,KACC,IAAI,KAAK,wBAAwB,GACjC,WAAW,KAAK,gBAAgB,KAAK,IAAI,CAAC,CAAC;EAEjD;;;;;;;;EAUA,kBAAe;AACb,UAAM,YAAY,KAAK,IAAG;AAC1B,UAAM,SAAS,KAAK,OAAM,EAAG,SAAS,EAAE,EAAE,UAAU,GAAG,EAAE;AACzD,WAAO,iBAAiB,SAAS,IAAI,MAAM,GAAG,YAAW;EAC3D;;;;;;EAOA,gBAAgB,gBAA8B;AAC5C,WAAO,CAAC,EACN,eAAe,cAAc,KAAI,KACjC,eAAe,eAAe,KAAI,KAClC,eAAe,eAAe,KAAI,KAClC,eAAe,SAAS,KAAI,KAC5B,eAAe,WAAW,KAC1B,eAAe,QAAQ,KACvB,eAAe,QAAQ;EAE3B;;;;;;EAOA,cAAc,SAAqB;AAKjC,WAAO,iCACF,UADE;MAEL,eAAe,IAAI,KAAK,QAAQ,aAAa,EAAE,mBAAkB;MACjE,eAAe,QAAQ;MACvB,gBAAgB,IAAI,KAAK,aAAa,SAAS;QAC7C,OAAO;QACP,UAAU;OACX,EAAE,OAAO,QAAQ,KAAK;;EAE3B;;;;;;;EASQ,mCAAmC,gBAA8B;AACvE,WAAO;MACL,eAAe,eAAe;MAC9B,gBAAgB,eAAe;MAC/B,gBAAgB,eAAe;MAC/B,SAAS,eAAe;MACxB,cAAc,eAAe;MAC7B,UAAU,eAAe;MACzB,OAAO,eAAe;MACtB,WAAW,eAAe;MAC1B,OAAO,eAAe;MACtB,gBAAgB,eAAe;MAC/B,gBAAgB,eAAe;MAC/B,gBAAgB,eAAe;;EAEnC;;;;EAKQ,mCACN,aACA,gBACA,eAAqB;AAErB,WAAO;MACL,eAAe,YAAY;MAC3B,gBAAgB,YAAY;MAC5B,gBAAgB,YAAY;MAC5B,SAAS,YAAY;MACrB,cAAc;MACd,UAAU,YAAY;MACtB,OAAO,YAAY;MACnB,WAAW,YAAY;MACvB,OAAO,WAAW,eAAe,QAAQ,eAAe,KAAK,GAAG;MAChE,gBAAgB;MAChB,kBAAkB;MAClB,gBAAgB;MAChB,SAAS,kBAAkB;MAC3B,gBAAgB,YAAY;MAC5B,gBAAgB,YAAY;;EAEhC;;;;EAKQ,yBAAyB,UAA4B;AAC3D,QAAI,SAAS,SAAS;AACpB,aAAO;QACL,SAAS;QACT,SAAS,SAAS;QAClB,OAAO,SAAS;;IAEpB;AAEA,WAAO;MACL,SAAS;MACT,OAAO,SAAS,SAAS;;EAE7B;;;;EAKQ,gBAAgB,OAAwB;AAC9C,YAAQ,MAAM,0BAA0B,KAAK;AAE7C,QAAI,eAAe;AAEnB,QAAI,MAAM,OAAO,SAAS;AACxB,qBAAe,MAAM,MAAM;IAC7B,WAAW,MAAM,SAAS;AACxB,qBAAe,MAAM;IACvB;AAEA,WAAO,WAAW,MAAM,IAAI,MAAM,YAAY,CAAC;EACjD;;qCAjQW,iBAAc,mBAAA,UAAA,GAAA,mBAAA,iBAAA,CAAA;EAAA;4EAAd,iBAAc,SAAd,gBAAc,WAAA,YAFb,OAAM,CAAA;;;;ACxDd,IAAO,qBAAP,MAAO,oBAAkB;EAGT;EAFH,gBAAgB,YAAY;EAE7C,YAAoB,MAAgB;AAAhB,SAAA,OAAA;EAAoB;;;;;;;;EASxC,iBACE,gBACA,aACA,eAAqB;AAErB,UAAM,SAAS,GAAG,KAAK,aAAa;AAEpC,UAAM,UAA8B;MAClC;MACA;MACA;;AAGF,WAAO,KAAK,KAAK,KAA0B,QAAQ,OAAO,EACvD,KACC,IAAI,cAAW;AACb,UAAI,SAAS,SAAS;AACpB,eAAO;UACL,SAAS;UACT,SAAS,SAAS,WAAW;;MAEjC,OAAO;AACL,eAAO;UACL,SAAS;UACT,OAAO,SAAS,SAAS;;MAE7B;IACF,CAAC,GACD,WAAW,WAAQ;AACjB,cAAQ,MAAM,6BAA6B,KAAK;AAChD,aAAO,WAAW,MAAM,IAAI,MAAM,8BAA8B,CAAC;IACnE,CAAC,CAAC;EAER;;;;;;EAOA,oBAAoB,gBAAsB;AACxC,UAAM,SAAS,GAAG,KAAK,aAAa,0BAA0B,cAAc;AAE5E,WAAO,KAAK,KAAK,IAA0B,MAAM,EAC9C,KACC,IAAI,cAAW;AACb,UAAI,SAAS,WAAW,SAAS,MAAM;AACrC,eAAO;UACL,SAAS;UACT,MAAM,SAAS;;MAEnB,OAAO;AACL,eAAO;UACL,SAAS;UACT,OAAO,SAAS,SAAS;;MAE7B;IACF,CAAC,GACD,WAAW,WAAQ;AACjB,cAAQ,MAAM,gCAAgC,KAAK;AACnD,aAAO,WAAW,MAAM,IAAI,MAAM,iCAAiC,CAAC;IACtE,CAAC,CAAC;EAER;;;;;;EAOA,mBAAmB,gBAAsB;AACvC,UAAM,SAAS,GAAG,KAAK,aAAa,0BAA0B,cAAc;AAE5E,WAAO,KAAK,KAAK,OAA4B,MAAM,EAChD,KACC,IAAI,cAAW;AACb,UAAI,SAAS,SAAS;AACpB,eAAO;UACL,SAAS;UACT,SAAS,SAAS,WAAW;;MAEjC,OAAO;AACL,eAAO;UACL,SAAS;UACT,OAAO,SAAS,SAAS;;MAE7B;IACF,CAAC,GACD,WAAW,WAAQ;AACjB,cAAQ,MAAM,+BAA+B,KAAK;AAClD,aAAO,WAAW,MAAM,IAAI,MAAM,iCAAiC,CAAC;IACtE,CAAC,CAAC;EAER;;;;;;EAOA,kCAAkC,gBAAsB;AACtD,WAAO,IAAI,WAAW,cAAW;AAE/B,WAAK,oBAAoB,cAAc,EAAE,UAAU;QACjD,MAAM,CAAC,oBAAmB;AACxB,cAAI,gBAAgB,WAAW,gBAAgB,MAAM;AACnD,qBAAS,KAAK,eAAe;AAC7B,qBAAS,SAAQ;UACnB,OAAO;AAEL,iBAAK,iCAAiC,cAAc,EAAE,UAAU;cAC9D,MAAM,CAAC,oBAAmB;AACxB,oBAAI,gBAAgB,WAAW,gBAAgB,MAAM;AACnD,2BAAS,KAAK,eAAe;AAC7B,2BAAS,SAAQ;gBACnB,OAAO;AACL,2BAAS,KAAK;oBACZ,SAAS;oBACT,OAAO;mBACR;AACD,2BAAS,SAAQ;gBACnB;cACF;cACA,OAAO,CAAC,UAAS;AACf,yBAAS,KAAK;kBACZ,SAAS;kBACT,OAAO;iBACR;AACD,yBAAS,SAAQ;cACnB;aACD;UACH;QACF;QACA,OAAO,CAAC,UAAS;AAEf,eAAK,iCAAiC,cAAc,EAAE,UAAU;YAC9D,MAAM,CAAC,oBAAmB;AACxB,kBAAI,gBAAgB,WAAW,gBAAgB,MAAM;AACnD,yBAAS,KAAK,eAAe;AAC7B,yBAAS,SAAQ;cACnB,OAAO;AACL,yBAAS,KAAK;kBACZ,SAAS;kBACT,OAAO;iBACR;AACD,yBAAS,SAAQ;cACnB;YACF;YACA,OAAO,CAAC,iBAAgB;AACtB,uBAAS,KAAK;gBACZ,SAAS;gBACT,OAAO;eACR;AACD,uBAAS,SAAQ;YACnB;WACD;QACH;OACD;IACH,CAAC;EACH;;;;;;EAOQ,iCAAiC,gBAAsB;AAC7D,WAAO,IAAI,WAAW,cAAW;AAC/B,UAAI;AACF,cAAM,uBAAuB,eAAe,QAAQ,gBAAgB;AACpE,cAAM,cAAc,eAAe,QAAQ,aAAa;AACxD,cAAM,gBAAgB,eAAe,QAAQ,eAAe;AAE5D,YAAI,yBAAyB,kBAAkB,eAAe,eAAe;AAC3E,gBAAM,oBAAoB,KAAK,MAAM,WAAW;AAChD,gBAAM,sBAAsB,WAAW,aAAa;AAEpD,mBAAS,KAAK;YACZ,SAAS;YACT,MAAM;cACJ,aAAa;cACb,eAAe;cACf,YAAW,oBAAI,KAAI,GAAG,YAAW;cACjC,WAAW,IAAI,KAAK,KAAK,IAAG,IAAK,KAAK,KAAK,KAAK,GAAI,EAAE,YAAW;;WAEpE;QACH,OAAO;AACL,mBAAS,KAAK;YACZ,SAAS;YACT,OAAO;WACR;QACH;AACA,iBAAS,SAAQ;MACnB,SAAS,OAAO;AACd,iBAAS,KAAK;UACZ,SAAS;UACT,OAAO;SACR;AACD,iBAAS,SAAQ;MACnB;IACF,CAAC;EACH;;;;;;;EAQA,iCACE,gBACA,aACA,eAAqB;AAErB,QAAI;AACF,qBAAe,QAAQ,kBAAkB,cAAc;AACvD,qBAAe,QAAQ,eAAe,KAAK,UAAU,WAAW,CAAC;AACjE,qBAAe,QAAQ,iBAAiB,cAAc,SAAQ,CAAE;IAClE,SAAS,OAAO;AACd,cAAQ,MAAM,oDAAoD,KAAK;IACzE;EACF;;;;EAKA,qCAAkC;AAChC,QAAI;AACF,qBAAe,WAAW,gBAAgB;AAC1C,qBAAe,WAAW,aAAa;AACvC,qBAAe,WAAW,eAAe;IAC3C,SAAS,OAAO;AACd,cAAQ,MAAM,sDAAsD,KAAK;IAC3E;EACF;;qCAtPW,qBAAkB,mBAAA,UAAA,CAAA;EAAA;4EAAlB,qBAAkB,SAAlB,oBAAkB,WAAA,YAFjB,OAAM,CAAA;;",
  "names": []
}
