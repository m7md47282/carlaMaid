{
  "version": 3,
  "sources": ["src/app/shared/services/payment.service.ts"],
  "sourcesContent": ["import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable, throwError } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\nimport { environment } from '../../../environments/environment';\n\n// Payment-related interfaces\nexport interface PaymentRequest {\n  amount: number;\n  currency: string;\n  orderId: string;\n  customerName: string;\n  customerEmail: string;\n  customerPhone: string;\n  description: string;\n  returnUrl: string;\n  cancelUrl: string;\n}\n\nexport interface PaymentResponse {\n  success: boolean;\n  payUrl?: string;\n  orderId?: string;\n  error?: string;\n  data?: any;\n}\n\nexport type PaymentStatusType = 'pending' | 'completed' | 'failed' | 'cancelled';\n\nexport interface PaymentStatus {\n  orderId: string;\n  status: PaymentStatusType;\n  amount?: number;\n  currency?: string;\n  transactionId?: string;\n  error?: string;\n}\n\n// SkipCash Webhook interfaces\nexport interface SkipCashWebhookPayload {\n  PaymentId: string;\n  Amount: string;\n  StatusId: number;\n  TransactionId: string | null;\n  Custom1: string | null;\n  Custom2: string | null;\n  Custom3: string | null;\n  Custom4: string | null;\n  Custom5: string | null;\n  Custom6: string | null;\n  Custom7: string | null;\n  Custom8: string | null;\n  Custom9: string | null;\n  Custom10: string | null;\n  VisaId: string;\n  TokenId: string;\n  CardType: string;\n  CardNumber: string | null;\n  RecurringSubscriptionId: string;\n}\n\n// SkipCash Status ID mapping\nexport const SKIPCASH_STATUS_MAP: Record<number, PaymentStatusType> = {\n  0: 'pending',    // New\n  1: 'pending',    // Pending\n  2: 'completed',  // Paid\n  3: 'cancelled',  // Canceled\n  4: 'failed',     // Failed\n  5: 'failed',     // Rejected\n  6: 'completed',  // Refunded\n  7: 'pending',    // Pending refund\n  8: 'failed'      // Refund failed\n};\n\n// Backend API response interfaces\ninterface BackendPaymentResponse {\n  success: boolean;\n  data?: any;\n  error?: string;\n}\n\ninterface BackendStatusResponse {\n  success: boolean;\n  data?: {\n    status?: string;\n    order_id?: string;\n    amount?: number;\n    currency?: string;\n    transaction_id?: string;\n  };\n  error?: string;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class PaymentService {\n  private readonly backendApiUrl = environment.backendApiUrl;\n  private readonly validPaymentStatuses: PaymentStatusType[] = ['pending', 'completed', 'failed', 'cancelled'];\n  private readonly maxAmount = 100000; // Maximum payment amount in QAR\n\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Create a new payment order with SkipCash via backend\n   * @param paymentRequest - The payment request details\n   * @returns Observable of payment response\n   */\n  createPayment(paymentRequest: PaymentRequest): Observable<PaymentResponse> {\n    const apiUrl = `${this.backendApiUrl}/skipcash/payment/create`;\n    \n    const payload = this.buildPaymentPayload(paymentRequest);\n\n    return this.http.post<BackendPaymentResponse>(apiUrl, payload)\n      .pipe(\n        map(this.handlePaymentCreationResponse.bind(this)),\n        catchError(this.handlePaymentError.bind(this))\n      );\n  }\n\n  /**\n   * Check payment status via backend\n   * @param orderId - The order ID to check\n   * @returns Observable of payment status\n   */\n  checkPaymentStatus(orderId: string): Observable<PaymentStatus> {\n    const apiUrl = `${this.backendApiUrl}/payment/status-skip-cash/${orderId}`;\n\n    return this.http.get<BackendStatusResponse>(apiUrl)\n      .pipe(\n        map(response => this.handleStatusResponse(response, orderId)),\n        catchError(this.handleStatusError.bind(this))\n      );\n  }\n\n  /**\n   * Map SkipCash StatusId to PaymentStatusType\n   * @param statusId - SkipCash StatusId (0-8)\n   * @returns PaymentStatusType\n   */\n  mapSkipCashStatus(statusId: number): PaymentStatusType {\n    return SKIPCASH_STATUS_MAP[statusId] || 'failed';\n  }\n\n  /**\n   * Process SkipCash webhook payload\n   * @param webhookPayload - Raw webhook data from SkipCash\n   * @returns Processed payment status\n   */\n  processWebhookPayload(webhookPayload: SkipCashWebhookPayload): PaymentStatus {\n    const status = this.mapSkipCashStatus(webhookPayload.StatusId);\n    const amount = webhookPayload.Amount ? parseFloat(webhookPayload.Amount) : undefined;\n    \n    return {\n      orderId: webhookPayload.TransactionId || webhookPayload.PaymentId,\n      status,\n      amount,\n      currency: 'QAR', // SkipCash uses QAR by default\n      transactionId: webhookPayload.PaymentId,\n      error: status === 'failed' ? `SkipCash StatusId: ${webhookPayload.StatusId}` : undefined\n    };\n  }\n\n  /**\n   * Test SkipCash API connectivity\n   * @returns Observable of connection test result\n   */\n  testSkipCashConnection(): Observable<{ success: boolean; message?: string; error?: string }> {\n    const apiUrl = `${this.backendApiUrl}/skipcash/health`;\n\n    return this.http.get<{ success: boolean; message?: string }>(apiUrl)\n      .pipe(\n        map(response => ({\n          success: response.success,\n          message: response.success ? 'SkipCash API is accessible' : 'SkipCash API is not accessible',\n          error: response.success ? undefined : 'SkipCash API is not accessible'\n        })),\n        catchError(error => {\n          console.error('SkipCash health check error:', error);\n          return throwError(() => new Error('SkipCash API health check failed'));\n        })\n      );\n  }\n\n  /**\n   * Generate a unique order ID\n   * @returns Unique order ID string\n   */\n  generateOrderId(): string {\n    const timestamp = Date.now();\n    const random = Math.random().toString(36).substring(2, 15);\n    return `CARLA_${timestamp}_${random}`.toUpperCase();\n  }\n\n  /**\n   * Validate payment amount\n   * @param amount - Amount to validate\n   * @returns True if amount is valid\n   */\n  validateAmount(amount: number): boolean {\n    return amount > 0 && amount <= this.maxAmount;\n  }\n\n  /**\n   * Format amount for display\n   * @param amount - Amount to format\n   * @param currency - Currency code (default: QAR)\n   * @returns Formatted amount string\n   */\n  formatAmount(amount: number, currency: string = 'QAR'): string {\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency: currency\n    }).format(amount);\n  }\n\n  /**\n   * Redirect to payment gateway\n   * @param paymentUrl - URL to redirect to\n   */\n  redirectToPayment(paymentUrl: string): void {\n    if (paymentUrl && paymentUrl.trim()) {\n      window.location.href = paymentUrl;\n    }\n  }\n\n  /**\n   * Handle payment callback from URL parameters\n   * @returns Payment status from URL parameters\n   */\n  handlePaymentCallbackFromUrl(): PaymentStatus {\n    const urlParams = new URLSearchParams(window.location.search);\n    const orderId = urlParams.get('order_id');\n    const status = urlParams.get('status');\n    const transactionId = urlParams.get('transaction_id');\n    const amount = urlParams.get('amount');\n    const currency = urlParams.get('currency');\n\n    if (!orderId || !status) {\n      return {\n        orderId: '',\n        status: 'failed',\n        error: 'Missing required callback parameters'\n      };\n    }\n\n    const validStatus = this.validatePaymentStatus(status);\n    const parsedAmount = amount ? parseFloat(amount) : undefined;\n\n    return {\n      orderId,\n      status: validStatus,\n      amount: parsedAmount,\n      currency: currency || 'QAR',\n      transactionId: transactionId || undefined\n    };\n  }\n\n  /**\n   * Get payment success URL\n   * @param orderId - Optional order ID to append\n   * @returns Success URL\n   */\n  getPaymentSuccessUrl(orderId?: string): string {\n    // We no longer append the orderId in the URL. It is stored locally and\n    // retrieved on the success page from sessionStorage.\n    const baseUrl = environment.skipCash.returnUrl;\n    return baseUrl;\n  }\n\n  /**\n   * Get payment cancel URL\n   * @param orderId - Optional order ID to append\n   * @returns Cancel URL\n   */\n  getPaymentCancelUrl(orderId?: string): string {\n    // We no longer append the orderId in the URL. It is stored locally and\n    // retrieved on the cancel page from sessionStorage.\n    const baseUrl = environment.skipCash.cancelUrl;\n    return baseUrl;\n  }\n\n  /**\n   * Log payment attempt for analytics\n   * @param paymentRequest - Payment request details\n   */\n  logPaymentAttempt(paymentRequest: PaymentRequest): void {\n    console.log('Payment attempt:', {\n      orderId: paymentRequest.orderId,\n      amount: paymentRequest.amount,\n      currency: paymentRequest.currency,\n      customerEmail: paymentRequest.customerEmail,\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  /**\n   * Log payment result for analytics\n   * @param orderId - Order ID\n   * @param status - Payment status\n   * @param error - Optional error message\n   */\n  logPaymentResult(orderId: string, status: string, error?: string): void {\n    console.log('Payment result:', {\n      orderId,\n      status,\n      error,\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  /**\n   * Log webhook processing for analytics\n   * @param webhookPayload - Webhook data received\n   * @param processedStatus - Processed payment status\n   */\n  logWebhookProcessing(webhookPayload: SkipCashWebhookPayload, processedStatus: PaymentStatus): void {\n    console.log('Webhook processed:', {\n      skipCashPaymentId: webhookPayload.PaymentId,\n      orderId: processedStatus.orderId,\n      originalStatusId: webhookPayload.StatusId,\n      mappedStatus: processedStatus.status,\n      amount: processedStatus.amount,\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  // Private helper methods\n\n  /**\n   * Build payment payload from request\n   */\n  private buildPaymentPayload(paymentRequest: PaymentRequest): any {\n    return {\n      amount: paymentRequest.amount.toString(),\n      currency: paymentRequest.currency,\n      customerName: paymentRequest.customerName,\n      customerEmail: paymentRequest.customerEmail,\n      customerPhone: paymentRequest.customerPhone,\n      description: paymentRequest.description,\n      returnUrl: paymentRequest.returnUrl,\n      cancelUrl: paymentRequest.cancelUrl,\n      orderId: paymentRequest.orderId\n    };\n  }\n\n  /**\n   * Handle payment creation response\n   */\n  private handlePaymentCreationResponse(response: BackendPaymentResponse): PaymentResponse {\n    console.log('SkipCash payment creation response:', response);\n    \n    if (response.success) {\n      return {\n        success: true,\n        data: response.data,\n      };\n    } else {\n      return {\n        success: false,\n        error: response.error || 'Payment creation failed'\n      };\n    }\n  }\n\n  /**\n   * Handle payment error\n   */\n  private handlePaymentError(error: any): Observable<never> {\n    console.error('Payment creation error:', error);\n    return throwError(() => new Error('Failed to create payment'));\n  }\n\n  /**\n   * Handle status response\n   */\n  private handleStatusResponse(response: BackendStatusResponse, orderId: string): PaymentStatus {\n    if (response.success && response.data) {\n      const status = response.data.status || 'pending';\n      const validStatus = this.validatePaymentStatus(status);\n      \n      return {\n        orderId: response.data.order_id || orderId,\n        status: validStatus,\n        amount: response.data.amount,\n        currency: response.data.currency,\n        transactionId: response.data.transaction_id\n      };\n    } else {\n      return {\n        orderId: orderId,\n        status: 'failed',\n        error: response.error || 'Failed to check payment status'\n      };\n    }\n  }\n\n  /**\n   * Handle status error\n   */\n  private handleStatusError(error: any): Observable<never> {\n    console.error('Payment status check error:', error);\n    return throwError(() => new Error('Failed to check payment status'));\n  }\n\n  /**\n   * Validate payment status\n   */\n  private validatePaymentStatus(status: string): PaymentStatusType {\n    return this.validPaymentStatuses.includes(status as PaymentStatusType) \n      ? status as PaymentStatusType\n      : 'failed';\n  }\n} "],
  "mappings": "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",
  "names": []
}
